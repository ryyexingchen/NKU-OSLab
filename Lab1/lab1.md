# lab1实验

## 练习1：理解内核启动中的程序入口操作



### 指令 `la sp, bootstacktop`的作用和目的：

将内核栈的顶部地址加载到栈指针寄存器`sp`中，目的是在操作系统启动时，初始化栈指针，确保栈指针指向内核栈的顶部，确保内核在执行过程中有可用的栈空间，并且栈的操作能够正确进行。

### `tail kern_init`的作用和目的：

执行`kern_init`函数，对内核进行初始化。使用tail进行跳转，会清除当前函数的栈帧，同时将控制权传递给另一个函数，避免了创建新的栈帧，这样做可以节省栈空间。

## 练习2：完善中断处理

根据代码提示将代码补全如下：

![image-20240926150650643](image\image-20240926150650643.png)

在这个函数中，先调用clock_set_next_event()设置时钟中断，并在中断发生后增加计数器，如果计数器达到了整百的数，就执行一次print命令并增加num，当执行了10次print后，使用sbi_shutdown进行关机操作。

执行make grade后结果如下：

![image-20240926151057584](image\image-20240926151057584.png)

## 扩展练习 Challenge1：描述与理解中断流程

观察trap.c和trapentry.S可以得知，在异常或中断发生时，首先会使用SAVE_ALL保存所有寄存器的值，再通过`move a0, sp`命令将栈指针的值移动到a0寄存器，再调用异常处理函数`trap_dispatch`函数判断是应该调用中断处理函数还是异常处理函数，通过`exception_handler`或`interrupt_handler`函数进行操作，最后通过RESTORE_ALL恢复所有寄存器的值。

### `mov a0，sp`的目的：

这样做的目的是为了将当前的栈指针传递给中断处理函数，当一个中断发生时，内核需要知道中断发生时的上下文环境，而栈指针是这个上下文中非常重要的一部分。通过将栈指针传递给中断处理函数，内核可以访问到中断发生时的完整上下文信息。

### SAVE_ALL中寄存器保存在栈中的位置：

首先用csrw sscratch, sp将当前的栈指针写入 `sscratch` 寄存器。其他寄存器的保存位置由偏移量决定的，`STORE x, x*REGBYTES(sp)`表示第x个寄存器保存到偏移量为`x*REGBYTES(sp)`的地方。

### 对于任何中断，__alltraps 中是否都需要保存所有寄存器：

x0寄存器其实可以不用存储，因为其应该始终保持0.

## 扩增练习 Challenge2：理解上下文切换机制

### `csrw sscratch, sp`和 `csrrw s0, sscratch, x0`的作用：

`csrw sscratch, sp`将当前的栈指针的值写入控制状态寄存器 `sscratch`，在发生异常或中断处理时保存原始的栈指针，以便之后可以恢复到异常发生时的上下文。

`csrrw s0, sscratch, x0`首先将` sscratch `寄存器的值读取到 s0，再将`sscratch`置0，目的是为了在发生异常或中断时，能够保存 `sscratch` 的原始值，以便之后可以恢复。

### 保存sbadvaddr和scause的作用：

sbadvaddr保存了导致异常的虚拟地址，scause保存导致异常的具体原因。保存这些CSR的值是为了在异常处理程序中能够访问到异常发生时的上下文信息。但是在异常处理完成后，这些值就不重要了，因为异常应该已经被处理了，所以可以不再restore。

## 扩展练习Challenge3：完善异常中断

根据提示代码修改如下：
![image-20240926162850334](image\image-20240926162850334.png)

先输出发生的异常类型和异常指令地址，再根据不同异常的类型更新tf->epc寄存器，以跳过异常指令。

执行结果如下图：
![image-20240926163457212](image\image-20240926163457212.png)


# Lab5:用户程序
## 一、实验目的

 * 了解第一个用户进程创建过程
 * 了解系统调用框架的实现机制
 * 了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理

## 二、实验过程

### 练习1: 加载应用程序并执行（需要编码）

`do_execv` 函数调用 `load_icode`（位于 kern/process/proc.c 中）来加载并解析一个处于内存中的 ELF 执行文件格式的应用程序。你需要补充 `load_icode` 的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好 `proc_struct` 结构中的成员变量 trapframe 中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的 trapframe 内容。

请在实验报告中简要说明你的设计实现过程。

- **请简要描述这个用户态进程被 ucore 选择占用 CPU 执行（RUNNING 态）到具体执行应用程序第一条指令的整个经过。**

---


  ### 练习2: 父进程复制自己的内存空间给子进程（需要编码）

创建子进程的函数 `do_fork` 在执行中将当前进程（即父进程）的用户内存地址空间中的合法内容复制给新进程（子进程），完成内存资源的复制。具体是通过 `copy_range` 函数（位于kern/mm/pmm.c中）实现的，请补充 `copy_range` 的实现，确保能够正确执行。

请在实验报告中简要说明你的设计实现过程。

- **如何设计实现 Copy on Write 机制？** 给出概要设计，鼓励给出详细设计。

> **Copy-on-write (简称COW)** 的基本概念是：如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源。若某使用者需要对该资源进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝——资源B，可对资源B进行写操作。该“写操作”使用者对资源B的改变对于其他使用者而言是不可见的，因为其他使用者看到的还是资源A。

---

### 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

请在实验报告中简要说明你对 fork/exec/wait/exit 函数的分析，并回答如下问题：

- **请分析 fork/exec/wait/exit 的执行流程。** 重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交替执行的？内核态执行结果是如何返回给用户程序的？
- **请给出 core 图：** 用户态进程的执行状态在各周期（包括执行状态、执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）

**执行：** `make grade`。如果显示的应用程序输出到输出，基本正确。（使用的是 qemu-1.0.1）

---
